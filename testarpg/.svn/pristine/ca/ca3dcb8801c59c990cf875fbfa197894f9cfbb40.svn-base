
module egret {

	export class SceneElementDriver extends SceneElementMover{
		/**
		 * 上次使用的技能
		 */
		public skillType:number;
		/**
		 * 是否为释放技能状态
		 */
		public isSkillStatus:boolean;
		/**
		 * 敌人数据
		 */
		public armies:Array<SceneElementDataItem>;
		//攻击目标
		public _attackTarget:SceneElementDataItem;
		/**
		 * 追击目标到达攻击范围时处理 function(target:SceneElementDataItem)
		 */
		public _chaseArriveItem:ScriptItem;
		//追击目标检测距离循环id
		private _chaseId:number;
		//追击目标循环id
		public _chaseTimerId:number;
		//血条
		public _hpBar:HPBar;
		//攻击计数
		public _timerCount:number = 0;
		//追击敌人时帧计数
		public _frameCount:number = 0;
		//是否锁定，锁定时不无法动弹，动画暂停
		public _isLocked:boolean;
		//伤害角度缓存
		public _radiansCache:Array<number> = [];
		//伤害对象缓存
		public _damageTargets:Array<SceneElementDataItem> = [];
		//技能释放时间
		private _skillTimeData:any = {};

		/**
		 * 构造函数
		 */
		public constructor(){
			super();

			this.speed = 3;

			this._hpBar = new egret.HPBar();
			this._namePad.show(this._hpBar,-1);
		}
		//
		public updateXY():void{
			super.updateXY();
		}
		//
		public addToScene():void{
			super.addToScene();

			this.updateHp();
		}
		//
		/**
		 * 更新血量显示
		 */
		public updateHp():void{
			var vo:SceneDriverVo = <SceneDriverVo>this._data.vo;
			this._hpBar.setProperty(vo.hp + "",vo.hp / vo.hpTotal);
		}
		/**
		 * 按指定动作类型和方向播放影片
		 * @param frameIndex:int = -1 开始播放的帧索引，-1时不设置开始播放的帧索引，从当前帧开始播放或从第0帧开始播放
		 * @param actionType:int = -1 动作类型，-1时不设置
		 * @param direction:int = -1 动作方向，-1时不设置
		 * @param loopCount:int = 0  播放循环次数，播放至最后一帧时即算循环了一次，0表示无限循环
		 * @param callBack:Function = null 设置播放次数时，播放完成后回调，仅执行一次
		 * @param thisObj:any = null 播放完成后回调函数所属对象
		 * @param startFun:Function = null 循环播放中开始播放时回调函数，每次循环执行一次
		 * @param startObj:any = null startFun回调函数所属对象
		 */
		public play(frameIndex:number = -1,actionType:number = -1,direction:number = -1,loopCount:number = 0,callBack:Function = null,thisObj:any = null,startFun:Function = null,startObj:any = null):void{
			if(this._isLocked) return;

			super.play.apply(this,arguments);

			this.clearAttack();
		}
		/**
		 * 从场景移除时处理 
		 * 
		 */		
		public removeFromScene():void{
			this.isSkillStatus = false;
			this.unlock();
			this.stopAttack();
			super.removeFromScene();
		}
		//
		/**
		 * 追击目标到达攻击范围时处理
		 * @param fun 回调函数 function(target:SceneElementDataItem) target:攻击目标
		 * @param target 回调函数所属对象
		 */
		public setChaseArriveHandler(fun:Function,target:any):void{
			if(!this._chaseArriveItem){
				this._chaseArriveItem = new egret.ScriptItem();
			}

			this._chaseArriveItem.execute = fun;
			this._chaseArriveItem.target = target;
		}
		//
		/**
		 * 追击敌人
		 * @param armies 敌人数据
		 */
		public chaseArmies(armies:Array<SceneElementDataItem>):void{
			if((<SceneDriverVo>this.data.vo).hp <= 0) return;

			this.armies = armies;

			if(this.armies){
				if (!TimerManager.getInstance().hasExecute(this._chaseTimerId))
					this._chaseTimerId = TimerManager.getInstance().addExecute(this.checkAutoAttack, this, 200);

				var max:number = 100000;
				var distance:number;
				var target:SceneElementDataItem;
				var x:number = this.x;
				var y:number = this.y;

				for(var i in this.armies){
					var vo:SceneDriverVo = <SceneDriverVo>this.armies[i].vo;
					if(vo.hp > 0){
						distance = DimensionUtil.distance2(x,y,vo.x,vo.y);

						if(distance < max){
                            max = distance;

							target = this.armies[i];
						}
					}
				}

				if(target){
					this._attackTarget = target;

					if(!this.checkChaseArrive()){
						if(!EnterFrameManager.getInstance().hasExecute(this._chaseId)){
							this._chaseId = EnterFrameManager.getInstance().addExecute(this.checkChaseArrive,this,3);
						}
					}
				}else{
					this._attackTarget = null;
					this.attackEnd();
				}
			}else{
				this._attackTarget = null;
				this.attackEnd();
			}
		}
		//
		/**
		 * 检测自动攻击
		 */
		public checkAutoAttack():void{
			this._timerCount ++;

			//1==200ms
			if(this._timerCount % 6 == 0){
				this.chaseArmies(this.armies);
			}
		}
		//
		/**
		 * 检测是否已到达攻击目标周围
		 */
		public checkChaseArrive():boolean{
			this._frameCount ++;
			var distance:number;
			var minRange:number = this.getElementMinRange();

			//检测场景元素之间是否太靠近
			//if(this.scene){
			//	var array:Array<any> = this.scene.getBiologyMap();
            //
			//	for(var i in array){
			//		if(array[i] instanceof SceneElementDriver && array[i] != this){
			//			var driver:SceneElementDriver = array[i];
			//			distance = DimensionUtil.distance2(this._x,this._y,driver.data.vo.x,driver.data.vo.y);
            //
			//			if(distance < minRange){
			//				var radian:number = Math.atan2(driver.data.vo.x - this._x,driver.data.vo.y - this._y);
			//				var param:number = radian < 0 ? 1 : -1;
			//				radian *= 180 / Math.PI;
			//				radian %= 90;
			//				radian = Math.abs(radian);
            //
			//				//靠近90度
			//				if(90 - radian < radian){
			//					var x:number = this._x;
			//					var y:number = this._y + param * minRange;
			//				}else{
			//					x = this._x + param * minRange;
			//					y = this._y;
			//				}
            //
			//				this.moveTo2(x,y);
			//				return;
			//			}
			//		}
			//	}
			//}

			if(this._isLocked) return false;

			//检测是否已到达攻击目标周围
			distance = DimensionUtil.distance2(this._x,this._y,this._attackTarget.vo.x,this._attackTarget.vo.y);

			//if(this.data.vo["vocation"]){
			//	LogManager.debug(this,"checkChaseArrive() distance = " + distance.toFixed(0) + "  vocation = " + this.data.vo["vocation"],this._x.toFixed(0),this._y.toFixed(0),this._attackTarget.vo.x.toFixed(0),this._attackTarget.vo.y.toFixed(0));
			//}

			if(distance < this.getAttackRange()){
				EnterFrameManager.getInstance().removeExecute(this._chaseId);

				this.attack();

				if(this._chaseArriveItem){
					this._chaseArriveItem.params = [this._attackTarget];
					this._chaseArriveItem.apply();
				}

				return true;
			}else if(this._frameCount % 3 == 0){
				this.moveTo2(this._attackTarget.vo.x,this._attackTarget.vo.y);
			}

			return false;
		}
		//
		/**
		 * 获取攻击范围，不同职业和怪物重写
		 * @returns {number}
		 */
		public getAttackRange():number{
			return 150;
		}
		//
		/**
		 * 获取场景元素之间最小距离，小于此距离时，场景元素自动朝不同方向分开
		 * @returns {number}
		 */
		public getElementMinRange():number{
			return 80;
		}
		//
		/**
		 * 默认攻击方法，不同职业和怪物重写
		 */
		public attack():void{
			if(this._isLocked) return;
			if(!this._attackTarget) return;
			if((<SceneDriverVo>this._attackTarget.vo).hp <= 0) return;

			this.stopMove();

			var direction:number = ActionMovieClipData.getInstance().calculateDirection(this.x,this.y,this._attackTarget.vo.x,this._attackTarget.vo.y);
			this.play(0,ActionType.ATTACK,direction,1,this.attackEnd,this);
			this._avatar.setFrameHandler(this.playSkill,this);
		}
		//
		/**
		 * 单次攻击结束
		 */
		public attackEnd():void{
			if(!this._attackTarget){
				TimerManager.getInstance().removeExecute(this._chaseTimerId);
			}
			if(this._avatar.actionType == ActionType.ATTACK)
				this.play(0,ActionType.PREPARE);
		}
		//
		/**
		 * 清理攻击相关数据和回调
		 */
		public clearAttack():void{
			this._timerCount = 0;
			this._avatar.setFrameHandler(null);
		}
		//
		/**
		 * 释放默认技能
		 */
		public playSkill():void{

		}
		//
		/**
		 * 停止攻击
		 */
		public stopAttack():void{
			this._attackTarget = null;

			this.stopMove();
			this.attackEnd();
			this.clearAttack();

			EnterFrameManager.getInstance().removeExecute(this._chaseId);
			TimerManager.getInstance().removeExecute(this._chaseTimerId);
		}
		//
		/**
		 * 切换场景特效
		 */
		public changeSceneEffect():void{
			this.stopAttack();

			this.enterSceneEffect();
		}
		//
		/**
		 * 进入场景特效
		 */
		public enterSceneEffect():void{
			if(this.scene){
				var effect:ElementEffect = <ElementEffect>SceneElementManager.getInstance().getElement(ElementEffect);
				effect.setIsCheckResource(false);
				effect.setMovieName(MovieName.EFFECT_01);
				this.scene.addElement(effect,SceneLayerType.BATTLE_EFFECT,this.x,this.y);
			}
		}
		//
		/**
		 * 计算伤害
		 * @param skillType 技能类型
		 */
		public damage(skillType:number = 0, targets:Array<SceneElementDataItem> = null):void{
			if(this._attackTarget){
				if(!targets)
					targets = this.getDamageTargets(skillType);
				var radians:Array<number> = this.getDamageRadians(targets);
				var damage:any = dataManager().fightData.damage(skillType,targets);

				globalUpdateWindows([UpdateType.DAMAGE_HP_CHANGE],targets,damage.damageValues,radians);
			}
		}
		//
		/**
		 * 获取技能伤害敌人数据，不同技能重写，默认为单体伤害敌人数据
		 * @param skillType 技能类型
		 * @returns {Array<SceneElementDataItem>}
		 */
		public getDamageTargets(skillType:number = 0):Array<SceneElementDataItem>{
			this._damageTargets.length = 0;
			this._damageTargets.push(this._attackTarget);
			return this._damageTargets;
		}
		//
		/**
		 * 获取伤害飘字角度数据
		 * @param targets 敌人数据
		 * @returns {Array<number>}
		 */
		public getDamageRadians(targets:Array<SceneElementDataItem>):Array<number>{
			this._radiansCache.length = 0;

			for(var i in targets){
				this._radiansCache.push(Math.atan2(targets[i].vo.y - this.y,targets[i].vo.x - this.x))
			}

			return this._radiansCache;
		}
		//
		/**
		 * 记录技能使用时间
		 * @param skillType
		 */
		public setSkillTime(skillType:number):void{
			this._skillTimeData[skillType] = getTimer();
		}
		//
		/**
		 * 获取上次使用技能经过的时间
		 * @param skillType
		 * @returns {number}
		 */
		public getSkillTime(skillType:number):number{
			if(this._skillTimeData[skillType])
				return getTimer() - this._skillTimeData[skillType];

			return 1000000000;
		}
		//
		/**
		 * 标记使用技能
		 * @param skillType
		 */
		public setUseSkill(skillType:number):void{
			this.setSkillTime(skillType);
			this.skillType = skillType;
		}
		//
		/**
		 * 锁定，锁定时不无法动弹，动画暂停
		 */
		public lock():void{
			this._isLocked = true;
			this._avatar.stopMovie();
		}
		//
		/**
		 * 解锁，恢复锁定前的动画播放
		 */
		public unlock():void{
			this._isLocked = false;
			this._avatar.playMovie();
		}
		//
		/**
		 * 被击退，从击退中心点以半径计算退后的坐标
		 * @param x 击退中心x
		 * @param y 击退中心x
		 * @param radius 击退半径
		 */
		public stepBack(x:number,y:number,radius:number):void{
			this.stopMove();

			var radian:number = Math.atan2(this._y - y, this._x - x);
			var tx:number = Math.cos(radian) * radius + x;
			var ty:number = Math.sin(radian) * radius + y;

			Tween.get(this).to({x:tx,y:ty},200).call(this.stepBackComplete,this,[tx,ty]);
		}
		//
		/**
		 * 击退结束
		 * @param x 击退目标点x
		 * @param y 击退目标点y
		 */
		public stepBackComplete(x:number,y:number):void{
			this.setXY(x,y);

			this.chaseArmies(this.armies);
		}
	}
}