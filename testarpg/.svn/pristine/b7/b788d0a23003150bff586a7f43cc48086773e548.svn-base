module egret{
    /**
     * 法师和射手普通攻击技能，打出去后，碰到敌人则消失
     */
    export class ElementMageNormalSkill extends ElementEffect{
        //攻击目标
        private _attackTarget:SceneElementDataItem;
        //帧循环id
        private _attackId:number;
        //移动速度
        private _speed:number = 10;
        //x ,y 轴速度
        private _speedX:number;
        private _speedY:number;
        //起始x,y
        private _originalX:number;
        private _originalY:number;
        //攻击目标点偏移x,y
        private _offsetAttackX:number;
        private _offsetAttackY:number;
        //是否已移动达到目标点
        private _isEnd:boolean;
        //技能半径
        private _radius:number;

        public constructor(){
            super();
        }
        //
        public addToScene():void{
            super.addToScene();

            this.play(0,ActionType.PREPARE,ActionMovieClipDirectionType.UP);
        }
        //
        public removeFromScene():void{
            super.removeFromScene();

            EnterFrameManager.getInstance().removeExecute(this._attackId);
        }
        //
        /**
         * 攻击目标
         * @param x 技能初始x
         * @param y 技能初始y
         * @param data 攻击目标数据
         * @param offsetX 攻击目标点偏移x
         * @param offsetY 攻击目标点偏移y
         * @param offsetRotation 攻击目标点偏移角度，因动作图片本身可能已有角度，用此参数纠正
         * @param radius 技能半径，超出半径则结束
         */
        public attackTo(x:number,y:number,data:SceneElementDataItem,offsetX:number,offsetY:number,offsetRotation:number,radius:number):void{
            this._originalX = x;
            this._originalY = y;
            this._attackTarget = data;
            this._offsetAttackX = offsetX;
            this._offsetAttackY = offsetY;
            this._radius = radius;

            this.x = x;
            this.y = y;

            var tx:number = this._attackTarget.vo.x + this._offsetAttackX;
            var ty:number = this._attackTarget.vo.y + this._offsetAttackY;

            var radian:number = Math.atan2(ty - y , tx - x);
            this._speedX = Math.cos(radian) * this._speed;
            this._speedY = Math.sin(radian) * this._speed;

            radian = radian / Math.PI * 180;
            this.rotation = radian + offsetRotation;

            this._isEnd = false;

            if(!EnterFrameManager.getInstance().hasExecute(this._attackId)){
                this._attackId = EnterFrameManager.getInstance().addExecute(this.moving,this,1);
            }
        }
        //
        /**
         * 技能移动
         */
        private moving():void{
            if(this._isEnd){
                EnterFrameManager.getInstance().removeExecute(this._attackId);

                this.playEnd();
                return;
            }

            var x:number = this._attackTarget.vo.x + this._offsetAttackX;
            var y:number = this._attackTarget.vo.y + this._offsetAttackY;

            var distance:number = DimensionUtil.distance2(this._x,this._y,x,y);

            //有可能敌人已经移动，所以使用3个单位作为范围检测，而不是一个单位
            if(Math.abs(distance) > this._speed * 3){
                this.x += this._speedX;
                this.y += this._speedY;

                distance = DimensionUtil.distance2(this._x,this._y,this._originalX,this._originalY);
                if(distance >= this._radius){
                    this._isEnd = true;
                }
            }else{
                this.x = this._attackTarget.vo.x;
                this.y = this._attackTarget.vo.y;

                this._isEnd = true;
            }
        }
        //
        /**
         * 获取部件影片地址
         * @param partType:String ActionPartType 动作影片类型
         * @return
         */
        public getPartUrl(partType:string):string{
            var path:string = PathData.PATH_MOVIES_SKILL;

            var movie:string = this._sceneAvatarVo[partType];

            var url:string = dataManager().sceneElementData.getActionUrl(path,movie,this._avatar.actionType);

            return url;
        }
    }
}